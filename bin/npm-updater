#!/usr/bin/perl

# Created on: 2016-06-08 08:23:05
# Create by:  Ivan Wills
# $Id$
# $Revision$, $HeadURL$, $Date$
# $Revision$, $Source$, $Date$

use strict;
use warnings;
use version;
use Scalar::Util;
use List::Util qw/max/;
#use List::MoreUtils;
use Getopt::Long;
use Pod::Usage;
use Data::Dumper qw/Dumper/;
use English qw/ -no_match_vars /;
use FindBin qw/$Bin/;
use Path::Tiny;
use JSON::XS qw/decode_json/;
use WWW::Mechanize::Cached;
use CHI;
use Term::ANSIColor qw/colored/;

our $VERSION = version->new('0.0.1');
my ($name)   = $PROGRAM_NAME =~ m{^.*/(.*?)$}mxs;

my %option = (
    cache   => '/tmp/npmupdater',
    verbose => 0,
    man     => 0,
    help    => 0,
    VERSION => 0,
);

sub sorter {
    my $A = $a;
    my $B = $b;
    $A =~ s/(\d+)/sprintf "%09i", $1/egxms;
    $B =~ s/(\d+)/sprintf "%09i", $1/egxms;
    return $A cmp $B;
}

main();
exit 0;

sub main {
    Getopt::Long::Configure('bundling');
    GetOptions(
        \%option,
        'cache|c=s',
        'verbose|v+',
        'man',
        'help',
        'VERSION!',
    ) or pod2usage(2);

    if ( $option{'VERSION'} ) {
        print "$name Version = $VERSION\n";
        exit 1;
    }
    elsif ( $option{'man'} ) {
        pod2usage( -verbose => 2 );
    }
    elsif ( $option{'help'} ) {
        pod2usage( -verbose => 1 );
    }

    # do stuff here
    my $mech = WWW::Mechanize::Cached->new(
        cache => CHI->new(
            driver   => 'File',
            root_dir => $option{cache},
        ),
    );
    my $package_json = @ARGV && -f $ARGV[0] ? shift @ARGV : 'package.json';
    my $package      = decode_json(scalar path($package_json)->slurp);
    my @types        = qw/dependencies devDependencies/;
    my %dependencies;

    for my $type (@types) {
        for my $dependency ( keys %{ $package->{$type} || {} } ) {
            my $details = eval {
                $mech->get('http://registry.npmjs.org/' . $dependency);
                decode_json($mech->content());
            } || {};
            warn $@ if $option{verbose} && $@;
            undef $@;
            my $current = path('node_modules', $dependency, 'package.json');
            my @versions = keys %{ $details->{versions} };

            my $versions = {
                $type     => 1,
                defined   => $package->{$type}{$dependency},
                available => @versions && ( sort sorter @versions )[-1],
            };

            if ( -f $current ) {
                my $actual = decode_json(scalar $current->slurp);
                $versions->{actual} = $actual->{version};
            }

            next if !$option{verbose}
                && $versions->{available}
                && $versions->{actual}
                && $versions->{available} eq $versions->{actual};

            $dependencies{$dependency} = $versions;
        }

    }

    my %max = (
        name      => (max (length "module"   , map {length $_} keys %dependencies)),
        defined   => (max (length "defined"  , map {length($dependencies{$_}{defined}   // '')} keys %dependencies)),
        actual    => (max (length "actual"   , map {length($dependencies{$_}{actual}    // '')} keys %dependencies)),
        available => (max (length "available", map {length($dependencies{$_}{available} // '')} keys %dependencies)),
    );

    for my $type (@types) {
        my $start = sprintf "%s\n  %-$max{name}s %$max{defined}s %$max{actual}s %$max{available}s\n", $type, 'Module', 'Defined', 'Actual', 'Available';

        for my $dependency (sort keys %dependencies) {
            next if !$dependencies{$dependency}{$type};

            print $start;
            $start = '';

            my @diff_actual = split /[.-]/, $dependencies{$dependency}{actual};
            my @diff_available = split /[.-]/, $dependencies{$dependency}{available};
            my @colors = qw/red magenta blue/;
            my $color = 'black';
            for my $i (0 .. $#colors) {
                if ( $diff_actual[$i] ne $diff_available[$i] ) {
                    $color = $colors[$i];
                    last;
                }
            }
            printf "  %-$max{name}s %$max{defined}s %$max{actual}s %s\n",
                $dependency,
                $dependencies{$dependency}{defined},
                $dependencies{$dependency}{actual} || ' ',
                colored([$color], sprintf "%$max{available}s", $dependencies{$dependency}{available} || ' ');
        }
        print "\n";
    }

    return;
}

__DATA__

=head1 NAME

npm-updater - Show what npm modules can be updated (and attempt to update to the latest where possible)

=head1 VERSION

This documentation refers to npm-updater version 0.0.1

=head1 SYNOPSIS

   npm-updater [option]

 OPTIONS:
  -c --cache[=]dir   Directory to store cached npmjs.com calls

  -v --verbose       Show more detailed option
     --version       Prints the version information
     --help          Prints this help information
     --man           Prints the full documentation for npm-updater

=head1 DESCRIPTION

=head1 SUBROUTINES/METHODS

=head1 DIAGNOSTICS

=head1 CONFIGURATION AND ENVIRONMENT

=head1 DEPENDENCIES

=head1 INCOMPATIBILITIES

=head1 BUGS AND LIMITATIONS

There are no known bugs in this module.

Please report problems to Ivan Wills (ivan.wills@gmail.com).

Patches are welcome.

=head1 AUTHOR

Ivan Wills - (ivan.wills@gmail.com)

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2016 Ivan Wills (14 Mullion Close, Hornsby Heights, NSW Australia 2077).
All rights reserved.

This module is free software; you can redistribute it and/or modify it under
the same terms as Perl itself. See L<perlartistic>.  This program is
distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.

=cut
